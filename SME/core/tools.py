import logging
import json
import re
import uuid
from typing import List, Dict, Any, Optional,Union
from pathlib import Path

from langchain_core.tools import tool
from langchain_core.messages import BaseMessage 

from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_LEFT
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter
from reportlab.lib.units import inch
from docx import Document as DocxDocument
from docx.shared import Inches, Pt
from pptx import Presentation
from pptx.util import Inches as PptxInches, Pt as PptxPt


import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders

import config
import prompts
from .models import llm_invoke

from .vector_store import PineconeRetriever

logger = logging.getLogger("rag.tools")


try:
    retriever = PineconeRetriever()
    logger.info("Tools: PineconeRetriever loaded.")
except Exception as e:
    logger.error(f"Tools: Failed to load PineconeRetriever: {e}")
    retriever = None


@tool
def send_email(file_path: str, recipient_email: str, subject: str) -> str:
    """
    Sends an email with a file as an attachment.
    Use this *after* a file has been generated by another tool.
    
    Args:
        file_path (str): The local path to the file to attach.
        recipient_email (str): The email address of the recipient.
        subject (str): The subject line for the email.
    """
    logger.info(f"Attempting to send email to {recipient_email} with file {file_path}")
    
    if not all([config.SMTP_SERVER, config.SMTP_SENDER_EMAIL, config.SMTP_SENDER_PASSWORD]):
        logger.warning("SMTP credentials not configured. Skipping email.")
        return "Error: Email server not configured."
        
    try:
        msg = MIMEMultipart()
        msg['From'] = config.SMTP_SENDER_EMAIL
        msg['To'] = recipient_email
        msg['Subject'] = subject
        
        body = f"Here is your requested document: {Path(file_path).name}"
        msg.attach(MIMEText(body, 'plain'))
        
        with open(file_path, "rb") as attachment:
            part = MIMEBase('application', 'octet-stream')
            part.set_payload(attachment.read())
        
        encoders.encode_base64(part)
        part.add_header('Content-Disposition', f"attachment; filename= {Path(file_path).name}")
        msg.attach(part)
        
        with smtplib.SMTP(config.SMTP_SERVER, config.SMTP_PORT) as server:
            server.starttls()
            server.login(config.SMTP_SENDER_EMAIL, config.SMTP_SENDER_PASSWORD)
            text = msg.as_string()
            server.sendmail(config.SMTP_SENDER_EMAIL, recipient_email, text)
            
        logger.info(f"Successfully sent email to {recipient_email}")
        return f"Successfully sent to {recipient_email}"
        
    except Exception as e:
        logger.error(f"Failed to send email: {e}")
        return f"Error: Failed to send email. {e}"



def get_pdf_styles():
    """Returns a stylesheet for professional-looking PDFs."""
    styles = getSampleStyleSheet()
    
    # Add H1 Style
    styles.add(ParagraphStyle(
        name='H1',
        parent=styles['Heading1'],
        fontSize=18,
        spaceAfter=14,
        alignment=TA_LEFT,
    ))
    
    # Add H2 Style
    styles.add(ParagraphStyle(
        name='H2',
        parent=styles['Heading2'],
        fontSize=14,
        spaceBefore=10,
        spaceAfter=10,
        alignment=TA_LEFT,
    ))
    
    # Add H3 Style
    styles.add(ParagraphStyle(
        name='H3',
        parent=styles['Heading3'],
        fontSize=12,
        spaceBefore=8,
        spaceAfter=6,
        alignment=TA_LEFT,
    ))
    
    # Add Body Text Style
    styles.add(ParagraphStyle(
        name='Body',
        parent=styles['Normal'],
        fontSize=10,
        spaceAfter=6,
        leading=14, # Line spacing
        alignment=TA_LEFT,
    ))
    
    # Add Bullet Style
    styles.add(ParagraphStyle(
        name='CustomBullet', # <-- FIX: Renamed from 'Bullet' to 'CustomBullet'
        parent=styles['Normal'],
        fontSize=10,
        leftIndent=36,
        spaceAfter=4,
        leading=14,
    ))
    
    # Add Numbered List Style
    styles.add(ParagraphStyle(
        name='ListNumber',
        parent=styles['Normal'],
        fontSize=10,
        leftIndent=36,
        spaceAfter=4,
        leading=14,
    ))
    
    return styles

def _create_pdf_tool(text: str, topic: str) -> str:
    """Creates a professional PDF report using Platypus."""
    filename = f"report_{re.sub(r'[^a-zA-Z0-9]', '_', topic)}_{uuid.uuid4().hex[:6]}.pdf"
    file_path = config.OUTPUT_DIR / filename
    
    doc = SimpleDocTemplate(str(file_path), pagesize=letter, leftMargin=inch, rightMargin=inch, topMargin=inch, bottomMargin=inch)
    styles = get_pdf_styles()
    story = []

    # --- Add Title ---
    story.append(Paragraph(f"Report: {topic.title()}", styles['H1']))
    story.append(Spacer(1, 0.25 * inch))

    # --- Process Text Content Line by Line ---
    for line in text.split('\n'):
        line_stripped = line.strip()
        
        # Check for markdown-style headings
        h3_match = re.match(r'^\s*###\s+(.+)', line_stripped)
        h2_match = re.match(r'^\s*##\s+(.+)', line_stripped)
        h1_match = re.match(r'^\s*#\s+(.+)', line_stripped)
        
        # Check for list items
        bullet_match = re.match(r'^\s*[\*\-•]\s+(.+)', line_stripped)
        number_match = re.match(r'^\s*\d+\.\s+(.+)', line_stripped)

        if h1_match:
            story.append(Paragraph(h1_match.group(1), styles['H1']))
        elif h2_match:
            story.append(Paragraph(h2_match.group(1), styles['H2']))
        elif h3_match:
            story.append(Paragraph(h3_match.group(1), styles['H3']))
        elif bullet_match:
            # Add the bullet symbol manually for PDF
            story.append(Paragraph(f"• {bullet_match.group(1)}", styles['CustomBullet']))
        elif number_match:
            # Re-add the number for PDF
            story.append(Paragraph(line_stripped, styles['ListNumber']))
        elif len(line_stripped) > 0:
            story.append(Paragraph(line_stripped, styles['Body']))
        else:
            # Add a small space for empty lines
            story.append(Spacer(1, 6)) # 6 points

    # --- doc.build() can raise errors, which will be caught by the fallback handler ---
    doc.build(story)
    logger.info(f"PDF report saved to: {file_path}")
    return str(file_path)


def _create_docx_tool(text: str, topic: str) -> str:
    """Creates a professional DOCX report with better style detection."""
    filename = f"report_{re.sub(r'[^a-zA-Z0-9]', '_', topic)}_{uuid.uuid4().hex[:6]}.docx"
    file_path = config.OUTPUT_DIR / filename
    
    doc = DocxDocument()
    doc.add_heading(f"Report: {topic.title()}", level=0)
    
    # --- Process Text Content Line by Line ---
    for line in text.split('\n'):
        line_stripped = line.strip()

        # Check for markdown-style headings
        h3_match = re.match(r'^\s*###\s+(.+)', line_stripped)
        h2_match = re.match(r'^\s*##\s+(.+)', line_stripped)
        h1_match = re.match(r'^\s*#\s+(.+)', line_stripped)
        
        # Check for list items
        bullet_match = re.match(r'^\s*[\*\-•]\s+(.+)', line_stripped)
        number_match = re.match(r'^\s*\d+\.\s+(.+)', line_stripped)

        if h1_match:
            doc.add_heading(h1_match.group(1), level=1)
        elif h2_match:
            doc.add_heading(h2_match.group(1), level=2)
        elif h3_match:
            doc.add_heading(h3_match.group(1), level=3)
        elif bullet_match:
            doc.add_paragraph(bullet_match.group(1), style='List Bullet')
        elif number_match:
            # Use List Number style, but keep the original text
            doc.add_paragraph(line_stripped, style='List Number')
        elif len(line_stripped) > 0:
            doc.add_paragraph(line_stripped, style='BodyText')
        else:
            # Add an empty paragraph for spacing
            doc.add_paragraph()
    
    doc.save(file_path)
    logger.info(f"DOCX report saved to: {file_path}")
    return str(file_path)

def _create_pptx_tool(text: str, topic: str) -> str:
    """Creates a basic PPTX report with slide-per-section logic."""
    filename = f"report_{re.sub(r'[^a-zA-Z0-9]', '_', topic)}_{uuid.uuid4().hex[:6]}.pptx"
    file_path = config.OUTPUT_DIR / filename
    
    prs = Presentation()
    
    # Title slide
    title_slide_layout = prs.slide_layouts[0]
    slide = prs.slides.add_slide(title_slide_layout)
    slide.shapes.title.text = f"Report: {topic.title()}"
    slide.shapes.placeholders[1].text = "Generated by RAG Agent"

    # Content slides
    content_slide_layout = prs.slide_layouts[1] # Title and Content
    current_slide = None
    text_frame = None

    for line in text.split('\n'):
        line_stripped = line.strip()

        h1_match = re.match(r'^\s*#\s+(.+)', line_stripped)
        h2_match = re.match(r'^\s*##\s+(.+)', line_stripped)
        bullet_match = re.match(r'^\s*[\*\-•]\s+(.+)', line_stripped)
        number_match = re.match(r'^\s*\d+\.\s+(.+)', line_stripped)

        # A new H1 or H2 creates a new slide
        if h1_match or h2_match:
            current_slide = prs.slides.add_slide(content_slide_layout)
            title_text = h1_match.group(1) if h1_match else h2_match.group(1)
            current_slide.shapes.title.text = title_text
            text_frame = current_slide.shapes.placeholders[1].text_frame
            if text_frame is None:
                text_frame = current_slide.shapes.add_textbox(PptxInches(1), PptxInches(1.5), PptxInches(8), PptxInches(5)).text_frame

        
        # Add content to the current slide
        elif text_frame is not None:
            if bullet_match:
                p = text_frame.add_paragraph()
                p.text = bullet_match.group(1)
                p.level = 1
            elif number_match:
                p = text_frame.add_paragraph()
                p.text = line_stripped
                p.level = 1
            elif len(line_stripped) > 0:
                p = text_frame.add_paragraph()
                p.text = line_stripped
        
        # Handle case where text comes before any H1/H2
        elif current_slide is None and len(line_stripped) > 0:
            current_slide = prs.slides.add_slide(content_slide_layout)
            current_slide.shapes.title.text = "Introduction"
            text_frame = current_slide.shapes.placeholders[1].text_frame
            p = text_frame.add_paragraph()
            p.text = line_stripped

    prs.save(file_path)
    logger.info(f"PPTX report saved to: {file_path}")
    return str(file_path)

def _create_quiz_pdf(quiz_data: List[Dict], topic: str) -> str:
    """Creates a professional PDF quiz using Platypus."""
    filename = f"quiz_{re.sub(r'[^a-zA-Z0-9]', '_', topic)}_{uuid.uuid4().hex[:6]}.pdf"
    file_path = config.OUTPUT_DIR / filename
    
    doc = SimpleDocTemplate(str(file_path), pagesize=letter, leftMargin=inch, rightMargin=inch, topMargin=inch, bottomMargin=inch)
    styles = get_pdf_styles()
    story = []

    # --- Add Title ---
    story.append(Paragraph(f"Quiz: {topic.title()}", styles['H1']))
    story.append(Spacer(1, 0.25 * inch))

    # --- Process Quiz Questions ---
    for i, item in enumerate(quiz_data):
        q_type = item.get("type", "unknown").upper()
        question = item.get("question", "No question text.")
        answer = item.get("answer", "No answer provided.")
        
        story.append(Paragraph(f"{i+1}. {question}", styles['H2']))
        story.append(Paragraph(f"<i>(Type: {q_type})</i>", styles['Body']))
        story.append(Spacer(1, 6))

        if q_type == "MCQ":
            options = item.get("options", [])
            for opt in options:
                story.append(Paragraph(f"• {opt}", styles['CustomBullet']))
        
        story.append(Spacer(1, 6))
        story.append(Paragraph(f"<b>Answer:</b> {answer}", styles['Body']))
        story.append(Spacer(1, 0.2 * inch))

    doc.build(story)
    logger.info(f"PDF quiz saved to: {file_path}")
    return str(file_path)

def _create_quiz_docx(quiz_data: List[Dict], topic: str) -> str:
    """Creates a professional DOCX quiz with better styles."""
    filename = f"quiz_{re.sub(r'[^a-zA-Z0-9]', '_', topic)}_{uuid.uuid4().hex[:6]}.docx"
    file_path = config.OUTPUT_DIR / filename
    
    doc = DocxDocument()
    doc.add_heading(f"Quiz: {topic.title()}", level=0)
    
    for i, item in enumerate(quiz_data):
        q_type = item.get("type", "unknown").upper()
        question = item.get("question", "No question text.")
        answer = item.get("answer", "No answer provided.")
        
        doc.add_heading(f"{i+1}. {question}", level=2)
        p_type = doc.add_paragraph()
        p_type.add_run(f"(Type: {q_type})").italic = True

        if q_type == "MCQ":
            options = item.get("options", [])
            for opt in options:
                doc.add_paragraph(opt, style='List Bullet')
        
        p_ans = doc.add_paragraph()
        p_ans.add_run("Answer: ").bold = True
        p_ans.add_run(str(answer))
        doc.add_paragraph()

    doc.save(file_path)
    logger.info(f"DOCX quiz saved to: {file_path}")
    return str(file_path)

def _create_quiz_pptx(quiz_data: List[Dict], topic: str) -> str:
    """Creates a professional PPTX quiz, one slide per question."""
    filename = f"quiz_{re.sub(r'[^a-zA-Z0-9]', '_', topic)}_{uuid.uuid4().hex[:6]}.pptx"
    file_path = config.OUTPUT_DIR / filename
    
    prs = Presentation()
    
    title_slide_layout = prs.slide_layouts[0]
    slide = prs.slides.add_slide(title_slide_layout)
    slide.shapes.title.text = f"Quiz: {topic.title()}"
    slide.shapes.placeholders[1].text = "Generated by RAG Agent"

    content_slide_layout = prs.slide_layouts[1]
    
    for i, item in enumerate(quiz_data):
        q_type = item.get("type", "unknown").upper()
        question = item.get("question", "No question text.")
        answer = item.get("answer", "No answer provided.")
        
        slide = prs.slides.add_slide(content_slide_layout)
        slide.shapes.title.text = f"{i+1}. {question}"
        text_frame = slide.shapes.placeholders[1].text_frame
        
        p_type = text_frame.add_paragraph()
        p_type.text = f"(Type: {q_type})"
        p_type.font.italic = True
        
        if q_type == "MCQ":
            options = item.get("options", [])
            for opt in options:
                p_opt = text_frame.add_paragraph()
                p_opt.text = opt
                p_opt.level = 1
        
        p_ans = text_frame.add_paragraph()
        run = p_ans.add_run()
        run.text = "Answer: "
        run.font.bold = True
        run = p_ans.add_run()
        run.text = str(answer)

    prs.save(file_path)
    logger.info(f"PPTX quiz saved to: {file_path}")
    return str(file_path)


# --- RAG/Parsing Helper Functions (No Change) ---
def _get_context(query: str, model_name: str) -> str:
    """Helper to fetch context using the new direct 2048-chunk search."""
    if not retriever:
        logger.error("Retriever is not initialized. Cannot get context.")
        return "Error: Retriever not available."
        
    docs = retriever.search_and_rerank(query, model_name)
    
    if not docs:
        logger.warning(f"No context found for query: {query}")
        return "No relevant context found."
    
    return "\n---\n".join([d.page_content for d in docs])

def _parse_thought_answer(llm_response: str) -> Dict[str, str]:
    """Parses 'Thought: ... Answer: ...' format."""
    thought_match = re.search(r"Thought:\s*(.*?)\s*Answer:", llm_response, re.DOTALL | re.IGNORECASE)
    answer_match = re.search(r"Answer:\s*(.*)", llm_response, re.DOTALL | re.IGNORECASE)

    thought = thought_match.group(1).strip() if thought_match else "No thought process was generated."
    answer = answer_match.group(1).strip() if answer_match else llm_response # Fallback

    if answer.strip() == "" and thought_match:
        answer = llm_response.split(thought_match.group(0))[-1].strip()

    return {"thought": thought, "answer": answer}


def _save_file_with_fallback(
    primary_format: str, 
    content_type: str, 
    content_data: Any,
    topic: str
) -> str:
    """
    Saves a file in the primary format with a robust fallback chain.
    If the primary format fails, it will try all other available formats.
    """
    # Define all available generators
    generators = {
        "report": {
            "pdf": _create_pdf_tool,
            "docx": _create_docx_tool,
            "pptx": _create_pptx_tool,
        },
        "quiz": {
            "pdf": _create_quiz_pdf,
            "docx": _create_quiz_docx,
            "pptx": _create_quiz_pptx,
        }
    }
    
    # Define the complete list of formats to try
    all_formats = ["pdf", "docx", "pptx"]
    
    primary_format = primary_format.lower()
    if primary_format not in all_formats:
            return f"Error: Unsupported format {primary_format}. Supported formats are pdf, docx, pptx."
    
    # Create a dynamic "try list"
    try_order = [primary_format]
    try_order.extend([f for f in all_formats if f != primary_format])

    
    gen_funcs = generators.get(content_type)
    if not gen_funcs:
            return f"Error: Unknown content type '{content_type}'."
            
    file_path = None
    last_error = "No valid format was attempted."
    
    for fmt in try_order:
        try:
            logger.info(f"Attempting to generate file in {fmt} format...")
            file_path = gen_funcs[fmt](content_data, topic)
            
            if file_path and not file_path.startswith("Error"):
                return file_path 
            
            last_error = file_path 
            
        except Exception as e:
            last_error = str(e)
            logger.warning(f"Failed to generate file in {fmt} format: {e}. Trying next fallback...")
    
    logger.error(f"Failed to generate file in all attempted formats. Last error: {last_error}")
    return f"Error: Failed to generate file. Last error: {last_error}"

@tool
def run_chat(query: str, model_name: str) -> Dict[str, str]:
    """
    Use this for general questions.
    The query should be a standalone question (pronouns resolved).
    
    Args:
        query (str): The user's question.
        model_name (str): The embedding model to use.
    """
    
    logger.info(f"Running chat tool for query: '{query}'")
    
    # 1. Run Retrieval
    context = _get_context(query, model_name)
    
    # 2. Generate Answer
    prompt = prompts.CHAT_PROMPT.replace("{{context}}", context).replace("{{query}}", query)
    llm_response = llm_invoke(prompt)
    
    return _parse_thought_answer(llm_response)


@tool
def generate_quiz(
    topic: str, 
    model_name: str, 
    num_mcq: int = 0, 
    num_subjective: int = 0, 
    num_fill_in_the_blanks: int = 0, 
    format: str = "pdf"
) -> Dict[str, Any]:
    """
    Generates a quiz file based on a topic and context.
    """
    # 1. Apply defaults ONLY if ALL are 0 (Respects user's input/desire)
    if num_mcq == 0 and num_subjective == 0 and num_fill_in_the_blanks == 0:
        logger.info("No specific counts provided. Applying defaults: 2 MCQ, 1 Subj, 1 Blank.")
        num_mcq = 2
        num_subjective = 1
        num_fill_in_the_blanks = 1
    else:
        logger.info(f"Using user-specified counts: {num_mcq} MCQ, {num_subjective} Subj, {num_fill_in_the_blanks} Blanks")

    context = _get_context(topic, model_name)
    prompt = prompts.QUIZ_PROMPT.replace("{{context}}", context) \
                                .replace("{{topic}}", topic) \
                                .replace("{{num_mcq}}", str(num_mcq)) \
                                .replace("{{num_subjective}}", str(num_subjective)) \
                                .replace("{{num_fill_in_the_blanks}}", str(num_fill_in_the_blanks))
    
    # 2. LLM Invoke and Parsing
    llm_response = llm_invoke(prompt)
    
    try:
        # A. Safest JSON Extraction (Look for the first '[' and last ']')
        json_start = llm_response.find("[")
        json_end = llm_response.rfind("]")
        
        if json_start == -1 or json_end == -1:
            raise ValueError("LLM response did not contain a valid JSON array for the quiz.")
             
        quiz_json_str = llm_response[json_start : json_end + 1]
        
        # B. Parse and save
        quiz_data = json.loads(quiz_json_str)
        file_path = _save_file_with_fallback(format, "quiz", quiz_data, topic)
        
        # C. Check for fallback file errors
        if file_path.startswith("Error"):
             # This means file saving failed (e.g., DOCX bug resurfaced, or folder issue)
             return {"error": file_path} 
             
        # D. Success return (Crucial: returns file_path key)
        return {"file_path": file_path}
        
    except Exception as e:
        logger.error(f"Quiz Generation Final Failure: {e}. Raw LLM Response: {llm_response[:200]}...")
        # Return structured error dict without file_path key
        return {
            "error": f"Quiz generation failed due to JSON/File Error: {str(e)}",
            "raw_response": llm_response
        }


@tool
def generate_report(
    topic: str, 
    format: str = "pdf", 
    model_name: str =""
) -> Dict[str, Any]:
    """
    Generates a report file based on a topic and context.
    Use when the user asks for a report, brief, document, or summary.
    This tool *only* creates the file and returns its path.
    It does *not* email the file.
    
    Args:
        topic (str): The topic for the report.
        format (str): The desired file format ('pdf', 'docx', 'pptx').
        model_name (str): The embedding model to use for retrieval.
    """
    logger.info(f"Generating {format} report for topic: '{topic}'")
    context = _get_context(topic, model_name)
    
    prompt = prompts.REPORT_PROMPT.replace("{{context}}", context) \
                                .replace("{{topic}}", topic)
                                
    llm_response = llm_invoke(prompt)
    
    try:
        thought_match = re.search(r"Thought:\s*(.*?)\s*Report:", llm_response, re.DOTALL | re.IGNORECASE)
        report_match = re.search(r"Report:\s*(.*)", llm_response, re.DOTALL | re.IGNORECASE)

        if thought_match and report_match:
            thought = thought_match.group(1).strip()
            report_text = report_match.group(1).strip()
        elif report_match: # Found "Report:" but not "Thought:"
            thought = "Generated report (no thought process was extracted)."
            report_text = report_match.group(1).strip()
        elif thought_match: # Found "Thought:" but not "Report:"
            thought = thought_match.group(1).strip()
            report_text = f"Error: LLM provided a thought but no report text. Thought: {thought}"
            logger.warning(f"Report generation failed: LLM provided thought but no report text for topic: {topic}")
        else: # Found neither
            thought = "Generated report (LLM did not follow formatting)."
            report_text = llm_response.strip() 
        
        if not report_text:
            report_text = "Error: Failed to parse report text from LLM response."
            logger.warning(f"Report generation failed: Parsed report text was empty for topic: {topic}")
     
        file_path = _save_file_with_fallback(
            primary_format=format,
            content_type="report",
            content_data=report_text,
            topic=topic
        )
        
        
        return {"thought": thought, "file_path": file_path}
        
    except Exception as e:
        logger.error(f"Failed to parse report from LLM response: {e}")
        return {
            "error": "Failed to generate report, LLM output was not valid.",
            "raw_response": llm_response
        }
